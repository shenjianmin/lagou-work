# Part 1 · JavaScript 深度剖析

## 模块二 ES新特性与TypeScript、JS性能优化 习题
&nbsp;

### 简答题
&nbsp;
### 一、请说出下列最终的执行结果，并解释为什么
``` js
var a = []
for(var i = 0;i<10;i++){
    a[i] = function(){
        console.log(i)
    }
}
a[6]()
```
答：

#### &emsp;&emsp;打印出的是10。因为用var声明的变量是没有块级作用域的，并且可以声明同名变量进行重新赋值。由于最后一次为i赋的值是10，此时全局作用域的i值为10，所以无论调用a数组中哪个位置的方法，都会打印10。
&nbsp;
### 二、请说出下列最终的执行结果，并解释为什么
``` js
var tmp = 123
if (true) {
    console.log(tmp)
    let tmp
}
```
答：

#### &emsp;&emsp;会报错，报出的错误信息是“无法在初始化之前访问‘tmp’”。因为用let声明会产生块级作用域，但是let声明不能够像var声明那样可以进行声明提升，所以在块级作用域中，不能在let声明之前打印出变量。
&nbsp;
### 三、结合ES6新语法，用最简单的方式找出数组中的最小值
答：
``` js
var arr = [12, 34, 32, 89, 4]
let minNum = Math.min(...arr)
```
&nbsp;
### 四、请详细说明var、let、const三种变量声明的方式之间的差异
答：

#### 1.var定义变量，没有块级作用域的概念，可以跨块级作用域访问，不能跨函数作用域访问，不初始化出现undefined，不会报错，var可以声明同名变量，可以声明提升。
#### 2.let定义变量，只能在块作用域里访问，也不能跨函数作用域问，对函数外部无影响，不可以声明同名变量，不可以声明提升。
#### 3.const定义常量，只能在块作用域里访问，也不能跨函数作用域访问，使用时必须初始化，即必须赋值，而且不能修改，不可以声明同名变量，不可以声明提升。
&nbsp;
### 五、请说出下列代码最终输出的结果，并解释为什么。
``` js
var a = 10
var obj = {
    a: 20,
    fn() {
        setTimeout(() => {
            console.log(this.a)
        })
    }
}
obj.fn()
```
答：

#### &emsp;&emsp;会打印出20。因为定时器里定义的是箭头函数，而箭头函数本身没有this的，所以箭头函数里的this值就是外面函数作用域里的this值，即fn中this值，而此时fn方法是有由obj对象调用的，所以此时fn中的this指向obj，所以this.a的值为20。
&nbsp;
### 六、简述Symbol类型的用途。
答：

#### 1.用于创建唯一的属性，可做唯一属性用于缓存等场景。
#### 2.用于创建类的私用变量，利用symbol属性不能被枚举的特性声明作为私用属性。
#### 3.用来重置对象的属性，比如Symbol.toStringTag
#### 4.可实现Symbol.iterator迭代器，让普通对象转变为可迭代对象。
#### 5.可以使用Symbol.for('')获取全局的symbol值。
&nbsp;
### 七、说说什么是浅拷贝，什么是深拷贝？
答：

#### &emsp;&emsp;深拷贝和浅拷贝最根本的区别在于是否是真正获取了一个对象的复制实体，而不是引用，深拷贝在计算机中开辟了一块内存地址用于存放复制的对象，而浅拷贝仅仅是指向被拷贝的内存地址，如果原地址中对象被改变了，那么浅拷贝出来的对象也会相应改变。
&nbsp;
### 八、请简述TypeScript与JavaScript之间的关系。
答：

#### &emsp;&emsp;TypeScript和JavaScript是目前项目开发中较为流行的两种脚本语言。JavaScript是轻量级的解释性脚本语言，可嵌入到HTML页面中，在浏览器端执行。而TypeScript是JavaScript的超集，即包含JavaScript的所有元素，能运行JavaScript的代码，并扩展了JavaScript的语法。相比于JavaScript，它还增加了静态类型、类、模块、接口和类型注解方面的功能，更易于大项目的开发。
&nbsp;
### 九、请谈谈你所认为的TypeScript的缺点。
答：

#### TypeScript 是 JavaScript 的一个超集，提供了类型系统和对ES6的支持，可编译成纯 JavaScript，可以运行在任何浏览器上，TS编译工具也可运行在任何服务器和系统上
#### 使用TS的好处：
#### （1）增强代码的可读性和可维护性，强类型的系统相当于最好的文档，在编译时即可发现大部分的错误，增强编辑器的功能。
#### （2）包容性，js文件可以直接改成 ts 文件，不定义类型可自动推论类型，可以定义几乎一切类型，ts 编译报错时也可以生成 js 文件，兼容第三方库，即使不是用ts编写的
#### （3）有活跃的社区，大多数的第三方库都可提供给 ts 的类型定义文件，完全支持 es6 规范
#### 使用 TS 的缺点：
#### （1）增加学习成本，需要理解接口（Interfaces）和泛型（Generics），类（class），枚举类型（Enums）
#### （2）短期增加开发成本，增加类型定义，但减少维护成本
#### （3）ts 集成到构建流程需要一定的工作量
#### （4）和有些库结合时不是很完美
&nbsp;
### 十、描述引用计数的工作原理和优缺点。
答：

#### 引用计数算法原理：
#### &emsp;&emsp;引用计数算法很简单，它实际上是通过在对象头中分配一个空间来保存该对象被引用的次数。如果该对象被其它对象引用，则它的引用计数加一，如果删除对该对象的引用，那么它的引用计数就减一，当该对象的引用计数为0时，那么该对象就会被回收。
#### 优点：
#### &emsp;&emsp;引用计数具有实时性，一旦没有引用，内存就直接释放了。不⽤像其他机制等到特定的时机。实时性还带来个好处，处理回收内存的时间分摊到了平时。
#### 缺点：
#### &emsp;&emsp;引用计数不能处理环形数据，即如果有两个对象相互引用，那么这两个对象就不能被回收，因为它们的引用计数始终为1。这也就是我们常说的“内存泄漏”问题。
&nbsp;
### 十一、描述标记整理算法的工作流程。
答：

#### &emsp;&emsp;分为三个阶段，标记、清除、整理。在标记阶段，collector从mutator根对象开始进行遍历，对从mutator根对象可以访问到的对象都打上一个标识，一般是在对象的header中，将其记录为可达对象。而在清除阶段，collector对堆内存(heap memory)从头到尾进行线性的遍历，如果发现某个对象没有标记为可达对象，通过读取对象的header信息，则将对象的地址进行移动，使其在地址上连续，然后再回收。
&nbsp;
### 十二、描述V8新生代存储区垃圾回收的流程。
答：

#### &emsp;&emsp;新生代内存中的垃圾回收主要通过 Scavenge 算法进行，具体实现时主要采用了 Cheney 算法。Cheney 将内存空间一分为二，每部分都叫做一个 Semispace，这两个 Semispace 一个处于使用，一个处于闲置。处于使用中的 Semispace 也叫作 From，处于闲置中的 Semispace 也叫作 To。在垃圾回收运行时时，会检查 From 中的对象，当某个对象需要被回收时，将其留在 From 空间，剩下的对象移动到 To 空间，然后进行反转，将 From 空间和 To 空间互换。进行垃圾回收时，会将 To 空间的内存进行释放。
&nbsp;
### 十三、描述增量标记算法在何时使用及工作原理。
答：

#### &emsp;&emsp;长时间的GC，会导致应用暂停和无响应，将会导致糟糕的用户体验。在新生代中，由于存活对象少，垃圾回收效率高，全停顿时间短，造成的影响小。但是老生代中，存活对象多，垃圾回收时间长，全停顿造成的影响大。为了减少全停顿的时间，V8对标记进行了优化，将一次停顿进行的标记过程，分成了很多小步。每执行完一小步就让应用逻辑执行一会儿，这样交替多次后完成标记。
